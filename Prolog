%Läs in filen
verify(Input) :-
    see(Input),
    read(T), read(L), read(S), read(F),
    seen,
    check(T, L, S, [], F), !.
  
  %p
  check(_, L, S, [], P) :-
    %Hitta alla värden som är sanna i S och lägg de i "Values"
    member([S, Values], L),
    %Rätt om P är ett av värderna funna i Values
    member(P, Values).
  
  %neg p
  check(_, L, S, [], neg(P)) :-
    %Hitta alla värden som är sanna i S och lägg de i "Values"
    member([S, Values], L),
    %Rätt om P är ett av värderna funna i Values
    \+member(P, Values).
  
  %And
  check(T, L, S, [], and(F,E)) :-
    check(T, L, S, [], F),
    check(T, L, S, [], E).
  
  %Or
  check(T, L, S, [], or(F,E)) :-
    check(T, L, S, [], F);
    check(T, L, S, [], E).
  
  %AX
  check(T, L, S, [], ax(F)) :-
    %Hitta alla som kommer efter S och lägg de i "PointsTo"
    member([S, PointsTo], T),
    %Anropa always med "PointsTo" som punkter man ska checka
    always(T, L, PointsTo, [], F).
  
  %AG1
  check(_, _, S, U, ag(_)) :-
    member(S, U).
  
  %AF1
  check(T, L, S, U, af(F)) :-
    %Kolla att S inte e medlem i U
    \+ member(S, U),
    check(T, L, S, [], F).
  
  %AG2
  check(T, L, S, U, ag(F)) :-
    %Om S inte är del av U
    \+ member(S, U),
    check(T, L, S, [], F),
    %Hitta alla som kommer efter S och lägg de i "PointsTo"
    member([S, PointsTo], T),
    %Anropa always med "PointsTo" som punkter man ska checka och U är listan [S|U]
    always(T, L, PointsTo, [S|U], ag(F)).
  
  %AF2
  check(T, L, S, U, af(F)) :-
    %Kolla att S inte e medlem i U
    \+ member(S, U),
    %Hitta alla som kommer efter S och lägg de i "PointsTo"
    member([S, PointsTo], T),
    %Anropa always med "PointsTo" som punkter man ska checka och U är listan [S|U]
    always(T, L, PointsTo, [S|U], af(F)).
  
  %EX
  check(T, L, S, [], ex(F)) :-
    %Hitta alla som kommer efter S och lägg de i "PointsTo"
    member([S, PointsTo], T),
    %Anropa exists med "PointsTo" som punkter man ska checka
    exists(T, L, PointsTo, [], F).
  
  %EG1
  check(_, _, S, U, eg(_)) :-
    member(S, U).
  
  %EG2
  check(T, L, S, U, eg(F)) :-
    %Kolla att S inte e medlem i U
    \+ member(S, U),
    %Kolla att det är true för när U är en tom lista
    check(T, L, S, [], F),
    %Hitta alla som kommer efter S och lägg de i "PointsTo"
    member([S, PointsTo], T),
    %Anropa exists med "PointsTo" som punkter man ska checka och U är listan [S|U]
    exists(T, L, PointsTo, [S|U], eg(F)).
  
  %EF1
  check(T, L, S, U, ef(F)) :-
    %Kolla att S inte e medlem i U
    \+ member(S, U),
    check(T, L, S, [], F).
  
  %EF2
  check(T, L, S, U, ef(F)) :-
    %Kolla att S inte e medlem i U
    \+ member(S, U),
    %Hitta alla som kommer efter S och lägg de i "PointsTo"
    member([S, PointsTo], T),
    %Anropa exists med "PointsTo" som punkter man ska checka och U är listan [S|U]
    exists(T, L, PointsTo, [S|U], ef(F)).
  
  
  %Eå vidare tills tredje agumentet är tomt eftersom då har vi gått igenom hela listan
  always(_, _, [], _, _).
  
  %U är inte tom
  always(T, L, [H|Tail], U, P) :-
    %Kolla att H gäller
    check(T, L, H, U, P),
    %Eå vidare till nästa och lägger till H till U (eftersom vi vill blockera H)
    always(T, L, Tail, [H|U], P).
  
  %U är tom
  always(T, L, [H|Tail], [], P) :-
    %Kolla att H gäller
    check(T, L, H, [], P),
    %Eå vidare till nästa
    always(T, L, Tail, [], P).
  
  %Hittade ingen punkt där det var sant så det leder till fail
  exists(_, _, [], _, _) :- fail.
  
  %U är inte tom
  exists(T, L, [H|Tail], U, P) :-
    %Kolla om det är sant för H
    check(T, L, H, U, P);
    %Annars fortsätter vi med tail och lägger till H till U (eftersom vi vill blockera H)
    exists(T, L, Tail, [H|U], P).
  
  %U är tom
  exists(T, L, [H|Tail], [], P) :-
    %Om detta är sant för H så slutar vi
    check(T, L, H, [], P);
    %Annars fortsätter vi med tail
    exists(T, L, Tail, [], P).